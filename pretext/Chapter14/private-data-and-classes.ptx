<?xml version="1.0"?>
<section xml:id="chapter14_private-data-and-classes">
  <title>Private data and classes</title>
  <p>I have used the word <term>encapsulation</term> in this book to refer to the
            process of wrapping up a sequence of instructions in a function, in
            order to separate the function's interface (how to use it) from its
            implementation (how it does what it does).</p>
  <p>This kind of encapsulation might be called <q>functional encapsulation,</q>
            to distinguish it from <q>data encapsulation,</q> which is the topic of this
            chapter. Data encapsulation is based on the idea that each structure
            definition should provide a set of functions that apply to the
            structure, and prevent unrestricted access to the internal
            representation.</p>
  <p>One use of data encapsulation is to hide implementation details from
            users or programmers that don't need to know them.</p>
  <p>For example, there are many possible representations for a <c>Card</c>,
            including two integers, two strings and two enumerated types. The
            programmer who writes the <c>Card</c> member functions needs to know which
            implementation to use, but someone using the <c>Card</c> structure should
            not have to know anything about its internal structure.</p>
  <p>As another example, we have been using <c>string</c> and <c>vector</c>
            objects without ever discussing their implementations. There are many
            possibilities, but as <q>clients</q> of these libraries, we don't need to
            know.</p>
  <p>In C++, the most common way to enforce data encapsulation is to prevent
            client programs from accessing the instance variables of an object. The
            keyword <c>private</c> is used to protect parts of a structure definition.
            For example, we could have written the <c>Card</c> definition:</p>
  <program>struct Card
{
private:
  int suit, rank;

public:
  Card();
  Card(int s, int r);

  int getRank() const { return rank; }
  int getSuit() const { return suit; }
  void setRank(int r) { rank = r; }
  void setSuit(int s) { suit = s; }
};</program>
  <p>There are two sections of this definition, a <term>private</term> part and a <term>public</term>
            part. The functions are public, which means that they can be invoked by
            client programs. The instance variables are private, which means that
            they can be read and written only by <c>Card</c> member functions.</p>
  <p>It is still possible for client programs to read and write the instance
            variables using the <term>accessor functions</term> (the ones beginning with
            <c>get</c> and <c>set</c>). On the other hand, it is now easy to control which
            operations clients can perform on which instance variables. For example,
            it might be a good idea to make cards <q>read only</q> so that after they are
            constructed, they cannot be changed. To do that, all we have to do is
            remove the <c>set</c> functions.</p>
  <p>Another advantage of using accessor functions is that we can change the
            internal representations of cards without having to change any client
            programs.</p>
  <listing label="priv_data_AC_1">
    <caption>
      <p>Run this active code. Uncomment the commented out code to see what happens!</p>
    </caption>
    <program xml:id="priv_data_AC_1_editor" interactive="activecode" line-numbers="yes">
      <input><![CDATA[
#include <iostream>
#include <string>
#include <vector>
using namespace std;

struct Card {
    private:
        int suit, rank;
    public:
        Card();
        Card(int s, int r);
        int getRank() const { return rank; }
        int getSuit() const { return suit; }
        void setRank(int r) { rank = r; }
        void setSuit(int s) { suit = s; }
        void print() const;
};

int main() {
    Card card (3, 8);
    card.print();
    cout << "Rank: " << card.getRank() << "    Suit: " << card.getSuit() << endl;
    card.setRank(12);
    card.setSuit(2);
    card.print();
    cout << "Rank: " << card.getRank() << "    Suit: " << card.getSuit() << endl;

    // If you uncomment the following code, you'll get an error! We cannot directly
    // access the private data members of Card, which is why we use accessor functions.

    /*
    cout << "Rank: " << card.rank << "\t Suit: " << card.suit << endl;
    card.rank = 4;
    card.suit = 0;
    */
}
        ]]></input>
      <tests>
Card::Card() {
    suit = 3;  rank = 0;
}

Card::Card(int s, int r) {
    suit = s;  rank = r;
}

void Card::print() const {
    vector&lt;string&gt; suits (4);
    suits[0] = "Clubs";
    suits[1] = "Diamonds";
    suits[2] = "Hearts";
    suits[3] = "Spades";

    vector&lt;string&gt; ranks (14);
    ranks[1] = "Ace";
    ranks[2] = "2";
    ranks[3] = "3";
    ranks[4] = "4";
    ranks[5] = "5";
    ranks[6] = "6";
    ranks[7] = "7";
    ranks[8] = "8";
    ranks[9] = "9";
    ranks[10] = "10";
    ranks[11] = "Jack";
    ranks[12] = "Queen";
    ranks[13] = "King";

    cout &lt;&lt; ranks[rank] &lt;&lt; " of " &lt;&lt; suits[suit] &lt;&lt; endl;
}
</tests>
    </program>
  </listing>
  <exercise label="question14_1_1">
    <statement>
      <p>Data encapsulation is based on the idea that each structure definition should provide a set of functions that
            apply to the structure, and allow unrestricted access to the internal representation.</p>
    </statement>
    <choices>
      <choice>
        <statement>
          <p>True</p>
        </statement>
        <feedback>
          <p>Incorrect! Data encapsulation should hide implementation details.</p>
        </feedback>
      </choice>
      <choice correct="yes">
        <statement>
          <p>False</p>
        </statement>
        <feedback>
          <p>Correct! Data encapsulation prevents unrestricted access to internal representations.</p>
        </feedback>
      </choice>
    </choices>
  </exercise>
  <exercise label="question14_1_2">
    <statement>
      <p>What type of data member cannot be directly accessed outside of the structure? <var/>  </p>
    </statement>
    <setup>
      <var case="insensitive">
        <condition string="^\s*(Pp)rivate||((Pp)rivate\s+(Dd)ata\s+(Mm)ember)\s*$">
          <feedback>
            <p>Correct!</p>
          </feedback>
        </condition>
        <condition string="^\s*.*\s*$">
          <feedback>
            <p>Incorrect! Try again.</p>
          </feedback>
        </condition>
      </var>
    </setup>
  </exercise>
  <exercise label="question14_1_3">
    <statement>
      <p>Multiple Response: Which of the following are examples of accessor functions?</p>
    </statement>
    <choices>
      <choice correct="yes">
        <statement>
          <p>getSuit</p>
        </statement>
        <feedback>
          <p>Correct!</p>
        </feedback>
      </choice>
      <choice correct="yes">
        <statement>
          <p>setRank</p>
        </statement>
        <feedback>
          <p>Correct! "Setter" functions are also known as "mutator" functions.</p>
        </feedback>
      </choice>
      <choice>
        <statement>
          <p>print</p>
        </statement>
        <feedback>
          <p>Incorrect!</p>
        </feedback>
      </choice>
      <choice correct="yes">
        <statement>
          <p>getRank</p>
        </statement>
        <feedback>
          <p>Correct!</p>
        </feedback>
      </choice>
    </choices>
  </exercise>
</section>
