<?xml version="1.0"?>
<section xml:id="chapter13_sorting-id1">
  <title>Sorting</title>
  <p>Now that we have messed up the deck, we need a way to put it back in
            order. Ironically, there is an algorithm for sorting that is very
            similar to the algorithm for shuffling.</p>
  <p>Again, we are going to traverse the deck and at each location choose
            another card and swap. The only difference is that this time instead of
            choosing the other card at random, we are going to find the lowest card
            remaining in the deck.</p>
  <p>By <q>remaining in the deck,</q> I mean cards that are at or to the right of
            the index <c>i</c>.</p>
  <program>for (size_t i = 0; i &lt; cards.size(); i++) {
  // find the lowest card at or to the right of i
  // swap the ith card and the lowest card
}</program>
  <p>Again, the pseudocode helps with the design of the <term>helper functions</term>.</p>
  <note>
    <p><term>Helper functions</term> do exactly what it seems like they would do.  They
                are shorter, simpler functions that <em>help</em> the bigger functions accomplish
                a task.  As a result, they shorten the code used in the bigger functions,
                and they make the debugging process easier.</p>
  </note>
  <p>In this case we can use <c>swapCards</c> again, so we only need one new
            one, called <c>findLowestCard</c>, that takes an index where it should start
            looking in the vector of cards.</p>
  <p>This process, using pseudocode to figure out what helper functions are
            needed, is sometimes called <term>top-down design</term>, in contrast to the
            bottom-up design I discussed in <number_reference internal="True" refuri="../Chapter10/counting#counting" title="Section %s"><inline classes="std std-numref">Section 10.10</inline></number_reference>.</p>
  <p>Once again, I am going to leave the implementation up to the reader.</p>
  <exercise label="sorting_deck_1">
    <statement>
      <p>If I'm writing a long, complex function with many steps, a(n) <var/> <var/>
would help me condense the function's code and make it easier to understand.  </p>
    </statement>
    <setup>
      <var case="insensitive">
        <condition string="^\s*helper\s*$">
          <feedback>
            <p>Correct!</p>
          </feedback>
        </condition>
        <condition string="^\s*.*\s*$">
          <feedback>
            <p>Try again!</p>
          </feedback>
        </condition>
      </var>
      <var case="insensitive">
        <condition string="^\s*function\s*$">
          <feedback>
            <p>Correct!</p>
          </feedback>
        </condition>
        <condition string="^\s*.*\s*$">
          <feedback>
            <p>Try again!</p>
          </feedback>
        </condition>
      </var>
    </setup>
  </exercise>
  <exercise label="sorting_deck_2">
    <statement>
      <p>Try writing the <c>findLowestCard</c> function in the commented section
            of this active code. Once you're done with <c>findLowestCard</c>,
            try using it along with <c>swapCards</c> to implement the <c>Deck</c> member
            function <c>sortDeck</c>. If done correctly, the program should output a
            sorted deck of cards. If you get stuck, you can reveal the extra problems
            at the end for help.</p>
    </statement>
    <program xml:id="sorting_deck_2_editor" interactive="activecode" line-numbers="yes">
      <input><![CDATA[
#include <iostream>
#include <string>
#include <vector>
#include <cstdlib>
using namespace std;

enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES };

enum Rank { ACE=1, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE,
TEN, JACK, QUEEN, KING };

int randomInt(int low, int high);

struct Card {
    Rank rank;
    Suit suit;
    Card();
    Card(Suit s, Rank r);
    void print() const;
    bool isGreater(const Card& c2) const;
};

struct Deck {
    vector<Card> cards;
    Deck();
    void print() const;
    void swapCards(int index1, int index2);
    int findLowestCard(int index);
    void shuffleDeck();
    void sortDeck();
};

int Deck::findLowestCard(int index) {
    // ``findLowestCard`` should search through the vector of cards
    // starting at index and return the index of the smallest card.
    // Delete the return 0 and write your implementation here.
    return 0;
}

void Deck::sortDeck() {
    // Follow the pseudocode from above and use ``findLowestCard`` and
    // ``swapCards`` to write the ``sort`` member function.
    // Write your implementation here.
}

int main() {
    Deck deck;
    deck.shuffleDeck();
    deck.sortDeck();
    deck.print();
}

        ]]></input>
      <tests>
Card::Card() {
    suit = SPADES;  rank = ACE;
}

Card::Card(Suit s, Rank r) {
    suit = s;  rank = r;
}

void Card::print() const {
    vector&lt;string&gt; suits(4);
    suits[0] = "Clubs";
    suits[1] = "Diamonds";
    suits[2] = "Hearts";
    suits[3] = "Spades";

    vector&lt;string&gt; ranks(14);
    ranks[1] = "Ace";
    ranks[2] = "2";
    ranks[3] = "3";
    ranks[4] = "4";
    ranks[5] = "5";
    ranks[6] = "6";
    ranks[7] = "7";
    ranks[8] = "8";
    ranks[9] = "9";
    ranks[10] = "10";
    ranks[11] = "Jack";
    ranks[12] = "Queen";
    ranks[13] = "King";

    cout &lt;&lt; ranks[rank] &lt;&lt; " of " &lt;&lt; suits[suit] &lt;&lt; endl;
}

bool Card::isGreater(const Card&amp; c2) const {
    if (suit &gt; c2.suit) return true;
    if (suit &lt; c2.suit) return false;
    if (rank &gt; c2.rank) return true;
    if (rank &lt; c2.rank) return false;
    return false;
}

Deck::Deck() {
    vector&lt;Card&gt; temp (52);
    cards = temp;

    int i = 0;
    for (Suit suit = CLUBS; suit &lt;= SPADES; suit = Suit(suit+1)) {
        for (Rank rank = ACE; rank &lt;= KING; rank = Rank(rank+1)) {
            cards[i].suit = suit;
            cards[i].rank = rank;
            i++;
        }
    }
}

void Deck::print() const {
    for (size_t i = 0; i &lt; cards.size(); i++) {
        cards[i].print();
    }
}

int randomInt(int low, int high) {
    srand (time(NULL));
    int x = random();
    int y = x % (high - low + 1) + low;
    return y;
}

void Deck::swapCards(int index1, int index2) {
    Card temp = cards[index1];
    cards[index1] = cards[index2];
    cards[index2] = temp;
}

void Deck::shuffleDeck() {
    for (size_t i = 0; i &lt; cards.size(); i++) {
        int x = randomInt (i, cards.size() - 1);
        swapCards (i, x);
    }
}
</tests>
    </program>
  </exercise>
  <exercises line="208" runestone_options="{'showtitle': 'data-showtitle=&quot;findLowestCard Help&quot;', 'hidetitle': 'data-hidetitle=&quot;Hide Problem&quot;', 'subchapter': 'sorting', 'chapter': 'Chapter13', 'basecourse': 'thinkcpp', 'optional': '', 'optclass': '', 'divid': 'sorting_reveal_1', 'instructoronly': '', 'is_dynamic': 'True'}" source="/mnt/f/Programming/Runestone2PreTeXt/book/_sources/Chapter13/sorting.rst">
    <exercise label="sorting_help_1" numbered="yes" adaptive="yes" indentation="hide">
      <statement>
        <p>Let's write the code for the findLowestCard function. findLowestCard
                should take an index as a parameter and return an int.</p>
      </statement>
      <blocks>
        <block order="4">
          <choice correct="yes">
            <cline>int Deck::findLowestCard(int index) {</cline>
          </choice>
          <choice>
            <cline>void Deck::findLowestCard(int index) {                         </cline>
          </choice>
        </block>
        <block order="3">
          <cline> int min = index;</cline>
        </block>
        <block order="5">
          <choice correct="yes">
            <cline><![CDATA[ for (size_t i = index; i < cards.size(); ++i) {]]></cline>
          </choice>
          <choice>
            <cline><![CDATA[ for (size_t i = 0; i < cards.size(); ++i) {                         ]]></cline>
          </choice>
        </block>
        <block order="9">
          <choice correct="yes">
            <cline>  if (cards[min].isGreater(cards[i])) {</cline>
          </choice>
          <choice>
            <cline>  if (cards[i].isGreater(cards[min])) {                         </cline>
          </choice>
        </block>
        <block order="10">
          <cline>   min = i;</cline>
          <cline>  }</cline>
          <cline> }</cline>
        </block>
        <block order="1">
          <choice correct="yes">
            <cline> return min;</cline>
            <cline>}</cline>
          </choice>
          <choice>
            <cline> return cards[min];                         </cline>
            <cline>}</cline>
          </choice>
        </block>
      </blocks>
    </exercise>
  </exercises>
  <exercises line="243" runestone_options="{'showtitle': 'data-showtitle=&quot;sortDeck Help&quot;', 'hidetitle': 'data-hidetitle=&quot;Hide Problem&quot;', 'subchapter': 'sorting', 'chapter': 'Chapter13', 'basecourse': 'thinkcpp', 'optional': '', 'optclass': '', 'divid': 'sorting_reveal_2', 'instructoronly': '', 'is_dynamic': 'True'}" source="/mnt/f/Programming/Runestone2PreTeXt/book/_sources/Chapter13/sorting.rst">
    <exercise label="sorting_help_2" numbered="yes" adaptive="yes" indentation="hide">
      <statement>
        <p>Let's write the code for the sortDeck function. We'll use findLowestCard
                and swapCards in our implementation of sortDeck.</p>
      </statement>
      <blocks>
        <block order="4">
          <choice correct="yes">
            <cline>void Deck::sortDeck() {</cline>
          </choice>
          <choice>
            <cline>Deck::sortDeck() {                         </cline>
          </choice>
        </block>
        <block order="1">
          <cline><![CDATA[ for (size_t i = 0; i < cards.size(); i++) {]]></cline>
        </block>
        <block order="5">
          <choice correct="yes">
            <cline>  int x = findLowestCard (i);</cline>
          </choice>
          <choice>
            <cline>  int x = findLowestCard (cards.size());                         </cline>
          </choice>
        </block>
        <block order="6">
          <cline>  swapCards (i, x);</cline>
          <cline> }</cline>
          <cline>}</cline>
        </block>
      </blocks>
    </exercise>
  </exercises>
</section>
